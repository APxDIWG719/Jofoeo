local nowprediction = true
local auto_parry_enabled = false
local personnel_detector_enabled = false
local ball_trial_Enabled = false
local strength = 0
local gravity_enabled = false
local current_curve = nil
local ai_Enabled = false
local auto_win = false
local tp_hit = false
local visualize_Enabled = false
local parry_mode = "Nothing"
local Helper = loadstring(game:HttpGet("https://paste.gg/p/anonymous/a650999fb8ed4d94bf896034ab55f7a6/files/b0255ee957424983a3c9946a12a663af/raw"))()
local RobloxReplicatedStorage = cloneref(game:GetService('RobloxReplicatedStorage'))
local RbxAnalyticsService = cloneref(game:GetService('RbxAnalyticsService'))
local ReplicatedStorage = cloneref(game:GetService('ReplicatedStorage'))
local UserInputService = cloneref(game:GetService('UserInputService'))
local NetworkClient = cloneref(game:GetService("NetworkClient"))
local TweenService = cloneref(game:GetService('TweenService'))
local VirtualUser = cloneref(game:GetService('VirtualUser'))
local HttpService = cloneref(game:GetService('HttpService'))
local RunService = cloneref(game:GetService('RunService'))
local LogService = cloneref(game:GetService('LogService'))
local Lighting = cloneref(game:GetService('Lighting'))
local CoreGui = cloneref(game:GetService('CoreGui'))
local Players = cloneref(game:GetService('Players'))
local Debris = cloneref(game:GetService('Debris'))
local Stats = cloneref(game:GetService('Stats'))

if not game:IsLoaded() then
	game.Loaded:Wait()
end

local crypter = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Egor-Skriptunoff/pure_lua_SHA/master/sha2.lua'), true))()

setfpscap(200)

local LocalPlayer = Players.LocalPlayer
local client_id = RbxAnalyticsService:GetClientId()

local names_map = {
	['protected'] = crypter.sha3_384(client_id, 'sha3-256'),

	['Pillow'] = crypter.sha3_384(client_id .. 'Pillow', 'sha3-256'),
	['Touhou'] = crypter.sha3_384(client_id .. 'Touhou', 'sha3-256'),
	['Shion'] = crypter.sha3_384(client_id .. 'Shion', 'sha3-256'),
	['Miku'] = crypter.sha3_384(client_id .. 'Miku', 'sha3-256'),
	['Sino'] = crypter.sha3_384(client_id .. 'Sino', 'sha3-256'),
	['Soi'] = crypter.sha3_384(client_id .. 'Soi', 'sha3-256')
}

local assets = game:GetObjects('rbxassetid://98657300657778')[1]

assets.Parent = RobloxReplicatedStorage
assets.Name = names_map['protected']

local effects_folder = assets.effects
local objects_folder = assets.objects
local sounds_folder = assets.sounds
local gui_folder = assets.gui

local RunTime = workspace.Runtime
local Alive = workspace.Alive
local Dead = workspace.Dead

local AutoParry = {
	ball = nil,
	target = nil,
	entity_properties = nil
}

local Player = {
	Entity = nil,

	properties = {
		grab_animation = nil
	}
}

Player.Entity = {
	properties = {
		sword = '',
		server_position = Vector3.zero,
		velocity = Vector3.zero,
		position = Vector3.zero,
		is_moving = false,
		speed = 0,
		ping = 0
	}
}

local World = {}

AutoParry.ball = {
	training_ball_entity = nil,
	client_ball_entity = nil,
	ball_entity = nil,

	properties = {
		last_ball_pos = Vector3.zero,
		aero_dynamic_time = tick(),
		hell_hook_completed = true,
		last_position = Vector3.zero,
		rotation = Vector3.zero,
		position = Vector3.zero,
		last_warping = tick(),
		parry_remote = nil,
		is_curved = false,
		last_tick = tick(),
		auto_spam = false,
		cooldown = false,
		respawn_time = 0,
		parry_range = 0,
		spam_range = 0,
		maximum_speed = 0,
		old_speed = 0,
		parries = 0,
		direction = 0,
		distance = 0,
		velocity = 0,
		last_hit = 0,
		lerp_radians = 0,
		radians = 0,
		speed = 0,
		dot = 0
	}
}

AutoParry.target = {
	current = nil,
	from = nil,
	aim = nil,
}

AutoParry.entity_properties = {
	server_position = Vector3.zero,
	velocity = Vector3.zero,
	is_moving = false,
	direction = 0,
	distance = 0,
	speed = 0,
	dot = 0
}


function create_animation(object: Instance, info: TweenInfo, value: table)
	local animation = TweenService:Create(object, info, value)

	animation:Play()

	task.wait(info.Time)

	Debris:AddItem(animation, 0)
	animation:Destroy()
	animation = nil
end

local function linear_predict(a: any, b: any, time_volume: number)
	return a + (b - a) * time_volume
end

function World:get_pointer()
	local mouse_location = UserInputService:GetMouseLocation()
	local ray = workspace.CurrentCamera:ScreenPointToRay(mouse_location.X, mouse_location.Y, 0)

	return CFrame.lookAt(ray.Origin, ray.Origin + ray.Direction)
end

function AutoParry.get_ball()
	for _, ball in workspace.Balls:GetChildren() do
		if ball:GetAttribute("realBall") then
			return ball
		end
	end
end

function AutoParry.get_client_ball()
	for _, ball in workspace.Balls:GetChildren() do
		if not ball:GetAttribute("realBall") then
			return ball
		end
	end
end

function makingtrail()
	local ball = nil

	-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸ªà¸£à¹‰à¸²à¸‡à¸«à¸£à¸·à¸­à¸­à¸±à¸›à¹€à¸”à¸• Trail
	local function createOrUpdateTrail()
		local Trail = ball:FindFirstChild("Trail")
		if not Trail then
			Trail = Instance.new("Trail")
			Trail.Name = "Trail"
			Trail.FaceCamera = true
			Trail.Parent = ball
		end

		local At1 = ball:FindFirstChild("at1")
		local At2 = ball:FindFirstChild("at2")

		if At1 and At2 then
			Trail.Attachment0 = At1
			Trail.Attachment1 = At2

			Trail.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.new(1.00, 0.00, 0.02)),
				ColorSequenceKeypoint.new(0.14, Color3.new(0.98, 1.00, 0.00)),
				ColorSequenceKeypoint.new(0.30, Color3.new(0.07, 1.00, 0.00)),
				ColorSequenceKeypoint.new(0.48, Color3.new(0.00, 0.98, 1.00)),
				ColorSequenceKeypoint.new(0.69, Color3.new(0.03, 0.00, 1.00)),
				ColorSequenceKeypoint.new(0.88, Color3.new(1.00, 0.00, 0.98)),
				ColorSequenceKeypoint.new(1.00, Color3.new(1.00, 0.00, 0.02))
			}

			Trail.WidthScale = NumberSequence.new{
				NumberSequenceKeypoint.new(0.00, 0.5, 0.00),
				NumberSequenceKeypoint.new(1.00, 0.00, 0.00)
			}

			Trail.Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0.00, 0.00, 0.00),
				NumberSequenceKeypoint.new(1.00, 1.00, 0.00)
			}

			Trail.Enabled = true
		end
	end

	-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¹€à¸›à¸´à¸” Trail à¹à¸¥à¸°à¸›à¸´à¸” ff
	local function enableTrailAndDisableFF()
		createOrUpdateTrail()

		local Trail = ball:FindFirstChild("Trail")
		if Trail then
			Trail.Enabled = true
		end

		local ff = ball:FindFirstChild("ff")
		if ff then
			ff.Enabled = false
		end
	end

	-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸›à¸´à¸” Trail à¹à¸¥à¸°à¹€à¸›à¸´à¸” ff
	local function disableTrailAndEnableFF()
		local Trail = ball:FindFirstChild("Trail")
		if Trail then
			Trail:Destroy()
		end

		local ff = ball:FindFirstChild("ff")
		if ff then
			ff.Enabled = true
		end
	end

		ball = Helper.getBall()

		if ball then
			if ball_trial_Enabled then
				enableTrailAndDisableFF()
			else
				disableTrailAndEnableFF()
			end
		end

end


local self = Helper.getBall()
local Visualize = Instance.new("Part",workspace)
Visualize.Color = Color3.new(0.14902, 1, 0.717647)
Visualize.Material = Enum.Material.ForceField
Visualize.Transparency = 0.5
Visualize.Anchored = true
	Visualize.CanCollide = false
	Visualize.CastShadow = false
	Visualize.Shape = Enum.PartType.Ball
	Visualize.Size = Vector3.new(30,30,30)
	
	local Highlight = Instance.new("Highlight")
	Highlight.Parent = Visualize
	Highlight.Enabled = true
	Highlight.FillTransparency = 0
	Highlight.OutlineColor = Color3.new(1, 1, 1)



	RunService.PreSimulation:Connect(function()
		if visualize_Enabled and LocalPlayer then
			Visualize.Transparency = 0
			Visualize.Material = Enum.Material.ForceField
			Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
			Visualize.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
		else
			Visualize.Material = Enum.Material.ForceField
			Visualize.Transparency = 1
		end	
	end)

function Player:get_aim_entity()
	local closest_entity = nil
	local minimal_dot_product = -math.huge
	local camera_direction = workspace.CurrentCamera.CFrame.LookVector

	for _, player in Alive:GetChildren() do
		if not player then
			continue
		end

		if player.Name ~= LocalPlayer.Name then
			if not player:FindFirstChild('HumanoidRootPart') then
				continue
			end

			local entity_direction = (player.HumanoidRootPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
			local dot_product = camera_direction:Dot(entity_direction)

			if dot_product > minimal_dot_product then
				minimal_dot_product = dot_product
				closest_entity = player
			end
		end
	end

	return closest_entity
end

function Player:get_closest_player_to_cursor()
	local closest_player = nil
	local minimal_dot_product = -math.huge

	for _, player in workspace.Alive:GetChildren() do
		if player == LocalPlayer.Character then
			continue
		end

		if player.Parent ~= Alive then
			continue
		end

		local player_direction = (player.PrimaryPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
		local pointer = World.get_pointer()
		local dot_product = pointer.LookVector:Dot(player_direction)

		if dot_product > minimal_dot_product then
			minimal_dot_product = dot_product
			closest_player = player
		end
	end

	return closest_player
end

function AutoParry.get_parry_remote()
	for _, object in { cloneref(game:GetService('AdService')), cloneref(game:GetService('SocialService')) }  do
		local temp_remote = object:FindFirstChildOfClass('RemoteEvent')

		if not temp_remote then
			continue
		end

		if not temp_remote.Name:find('\n') then
			continue
		end

		AutoParry.ball.properties.parry_remote = temp_remote
	end
end

AutoParry.get_parry_remote()

function AutoParry.perform_grab_animation()
	local animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
	local currently_equipped = Player.Entity.properties.sword

	if not currently_equipped or currently_equipped == 'Titan Blade' then
		return
	end

	if not animation then
		return
	end

	local sword_data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)

	if not sword_data or not sword_data['AnimationType'] then
		return
	end

	local character = LocalPlayer.Character

	if not character or not character:FindFirstChild('Humanoid') then
		return
	end

	for _, object in ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren() do
		if object.Name ~= sword_data['AnimationType'] then
			continue
		end

		if not (object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab')) then
			continue
		end

		local sword_animation_type = 'GrabParry'

		if object:FindFirstChild('Grab') then
			sword_animation_type = 'Grab'
		end

		animation = object[type]
	end

	Player.properties.grab_animation = character.Humanoid:LoadAnimation(animation)
	Player.properties.grab_animation:Play()
end

function AutoParry.perform_parry()
	local ball_properties = AutoParry.ball.properties

	if ball_properties.cooldown and not ball_properties.auto_spam then
		return
	end

	ball_properties.parries += 1
	AutoParry.ball.properties.last_hit = tick()

	local camera = workspace.CurrentCamera
	local camera_direction = camera.CFrame.Position

	local direction = camera.CFrame
	local target_position = AutoParry.entity_properties.server_position

	if not ball_properties.auto_spam then
		AutoParry.perform_grab_animation()

		ball_properties.cooldown = true



		if current_curve == 'Straight' then
			direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position)
		end

		if current_curve == 'Backwards' then
			direction = CFrame.new(camera_direction, (camera_direction + (-camera.CFrame.LookVector * 10000)) + Vector3.new(0, 1000, 0))
		end

		if current_curve == 'Randomizer' then
			direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Vector3.new(math.random(-1000, 1000), math.random(-350, 1000), math.random(-1000, 1000)))
		end

		if current_curve == 'Boost' then
			direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + Vector3.new(0, 150, 0))
		end
	else
		direction = CFrame.new(camera_direction, target_position + Vector3.new(0, 60, 0))

		ball_properties.parry_remote:FireServer(
			0,
			direction,
			{ [AutoParry.target.aim.Name] = target_position },
			{ target_position.X, target_position.Y },
			false
		)

		task.delay(1, function()
			if ball_properties.parries > 0 then
				ball_properties.parries -= 1
			end
		end)

		return
	end

	ball_properties.parry_remote:FireServer(
		0.5,
		direction,
		{ [AutoParry.target.aim.Name] = target_position },
		{ target_position.X, target_position.Y },
		false
	)

	task.delay(0.5, function()
		if ball_properties.parries > 0 then
			ball_properties.parries -= 1
		end
	end)
end

function AutoParry.reset()
    nowprediction = true
	AutoParry.ball.properties.is_curved = false
	AutoParry.ball.properties.auto_spam = false
	AutoParry.ball.properties.cooldown = false
	AutoParry.ball.properties.maximum_speed = 0
	AutoParry.ball.properties.parries = 0
	AutoParry.entity_properties.server_position = Vector3.zero
	AutoParry.target.current = nil
	AutoParry.target.from = nil
end

ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker: Model)
	if hooker.Name == LocalPlayer.Name then
		AutoParry.ball.properties.hell_hook_completed = true

		return
	end

	AutoParry.ball.properties.hell_hook_completed = false
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
	AutoParry.ball.properties.hell_hook_completed = true
end)

function AutoParry.is_curved()
	local target = AutoParry.target.current

	if not target then
		return false
	end

	local ball_properties = AutoParry.ball.properties
	local current_target = AutoParry.target.current.Name

	if target.PrimaryPart:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		ball_properties.auto_spam = false

		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
		return true
	end

	if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
		Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)

		ball_properties.auto_spam = false
		ball_properties.aero_dynamic_time = tick()
	end

	if RunTime:FindFirstChild('Tornado') then
		if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
			return true
		end
	end

	if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then
		return true
	end

	local ball_direction = ball_properties.velocity.Unit
	local ball_speed = ball_properties.speed

	local speed_threshold = math.min(ball_speed / 100, 40)
	local angle_threshold = 40 * math.max(ball_properties.dot, 0)

	local player_ping = Player.Entity.properties.ping

	local accurate_direction = ball_properties.velocity.Unit
	accurate_direction *= ball_direction

	local direction_difference = (accurate_direction - ball_properties.velocity).Unit
	local accurate_dot = ball_properties.direction:Dot(direction_difference)
	local dot_difference = ball_properties.dot - accurate_dot
	local dot_threshold = 0.5 - player_ping / 1000

	local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
	local enough_speed = ball_properties.maximum_speed > 100

	local ball_distance_threshold = 15 - math.min(ball_properties.distance / 1000, 15) + angle_threshold + speed_threshold

	if enough_speed and reach_time > player_ping / 10 then
		ball_distance_threshold = math.max(ball_distance_threshold - 15, 15)
	end

	if ball_properties.distance < ball_distance_threshold then
		return false
	end

	if dot_difference < dot_threshold then
		return true
	end

	if ball_properties.lerp_radians < 0.018 then
		ball_properties.last_curve_position = ball_properties.position
		ball_properties.last_warping = tick() 
	end

	if (tick() - ball_properties.last_warping) < (reach_time / 1.5) then
		return true
	end

	return ball_properties.dot < dot_threshold
end

local old_from_target = nil :: Model

function AutoParry:is_spam() --// im autistic ðŸ˜
	local target = AutoParry.target.current

	if not target then
		return false
	end

	if AutoParry.target.from ~= LocalPlayer.Character then
		old_from_target = AutoParry.target.from
	end

	if self.parries < 3 and AutoParry.target.from == old_from_target then
		return false
	end

	local player_ping = Player.Entity.properties.ping
	local distance_threshold = 18 + (player_ping / 80)

	local ball_properties = AutoParry.ball.properties
	local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)

	if (tick() - self.last_hit) > 0.8 and self.entity_distance > distance_threshold and self.parries < 3 then
		self.parries = 1

		return false
	end

	if ball_properties.lerp_radians > 0.028 then
		if self.parries > 3 then
			self.parries = 1
		end

		return false
	end

	if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and self.entity_distance > distance_threshold and self.parries < 4 then
		if self.parries > 3 then
			self.parries = 1
		end

		return false
	end

	if math.abs(self.speed - self.old_speed) < 5.2 and self.entity_distance > distance_threshold and self.speed < 60 and self.parries < 3 then
		if self.parries > 3 then
			self.parries = 0
		end

		return false
	end

	if self.speed < 10 then
		self.parries = 1

		return false
	end

	if self.maximum_speed < self.speed and self.entity_distance > distance_threshold then
		self.parries = 1

		return false
	end

	if self.entity_distance > self.range and self.entity_distance > distance_threshold then
		if self.parries > 2 then
			self.parries = 1
		end

		return false
	end

	if self.ball_distance > self.range and self.entity_distance > distance_threshold then
		if self.parries > 2 then
			self.parries = 2
		end

		return false
	end

	if self.last_position_distance > self.spam_accuracy and self.entity_distance > distance_threshold then
		if self.parries > 4 then
			self.parries = 2
		end

		return false
	end

	if self.ball_distance > self.spam_accuracy and self.ball_distance > distance_threshold then
		if self.parries > 3 then
			self.parries = 2
		end

		return false
	end

	if self.entity_distance > self.spam_accuracy and self.entity_distance > (distance_threshold - math.pi) then
		if self.parries > 3 then
			self.parries = 2
		end

		return false
	end

	return true	
end

function Player:claim_rewards()
	repeat
		task.wait(1)
	until not AutoParry.ball.properties.auto_spam

	local net = ReplicatedStorage:WaitForChild("Packages")['_Index']['sleitnick_net@0.1.0'].net

	ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer('ClaimLoginReward')

	task.defer(function()
		for day = 1, 30 do
			task.wait()

			ReplicatedStorage.Remote.RemoteFunction:InvokeServer('ClaimNewDailyLoginReward', day)

			net:WaitForChild("RE/SummerWheel/ProcessRoll"):FireServer()
			net:WaitForChild("RE/SummerWheel/ClaimReward"):FireServer()

			net:WaitForChild("RE/ProcessTournamentEventRoll"):FireServer()
			net:WaitForChild("RE/CyborgWheel/ProcessRoll"):FireServer()
			net:WaitForChild("RE/SynthWheel/ProcessRoll"):FireServer()
			net:WaitForChild("RE/ProcessTournamentRoll"):FireServer()
			net:WaitForChild("RE/RolledReturnCrate"):FireServer()
			net:WaitForChild("RE/ProcessLTMRoll"):FireServer()
		end
	end)

	task.defer(function()
		for reward = 1, 6 do
			net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(reward)
			net:WaitForChild("RE/ClaimSeasonPlaytimeReward"):FireServer(reward)

			ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer('SpinWheel')
			net:WaitForChild("RE/SpinFinished"):FireServer()
		end
	end)

	task.defer(function()
		for reward = 1, 5 do
			net:WaitForChild("RF/RedeemQuestsType"):InvokeServer('SummerClashEvent', 'Daily', reward)
		end
	end)

	task.defer(function()
		for reward = 1, 4 do
			net:WaitForChild("RE/SummerWheel/ClaimStreakReward"):FireServer(reward)
		end
	end)
end

RunService:BindToRenderStep('server position simulation', 1, function()
	local ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()

	if not LocalPlayer.Character then
		return
	end

	if not LocalPlayer.Character.PrimaryPart then
		return
	end

	local PrimaryPart = LocalPlayer.Character.PrimaryPart
	local old_position = PrimaryPart.Position

	task.delay(ping / 1000, function()
		Player.Entity.properties.server_position = old_position
	end)
end)

RunService.PreSimulation:Connect(function()
	NetworkClient:SetOutgoingKBPSLimit(math.huge)

	local character = LocalPlayer.Character

	if not character then
		return
	end

	if not character.PrimaryPart then
		return
	end

	local player_properties = Player.Entity.properties

	player_properties.sword = character:GetAttribute('CurrentlyEquippedSword')
	player_properties.ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
	player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
	player_properties.speed = Player.Entity.properties.velocity.Magnitude
	player_properties.is_moving = Player.Entity.properties.speed > 30
end)


RunService.PreSimulation:Connect(function()
	makingtrail()
end)
AutoParry.ball.ball_entity = AutoParry.get_ball()
AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()

RunService.PreSimulation:Connect(function()
	local ball = AutoParry.ball.ball_entity

	if not ball then
		return
	end

	local zoomies = ball:FindFirstChild('zoomies')

	local ball_properties = AutoParry.ball.properties

	ball_properties.position = ball.Position
	ball_properties.velocity = ball.AssemblyLinearVelocity

	if zoomies then
		ball_properties.velocity = ball.zoomies.VectorVelocity
	end

	ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
	ball_properties.speed = ball_properties.velocity.Magnitude
	ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
	ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
	ball_properties.radians = math.rad(math.asin(ball_properties.dot))
	ball_properties.lerp_radians = linear_predict(ball_properties.lerp_radians, ball_properties.radians, 0.8)

	if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
		ball_properties.lerp_radians = 0.027
	end

	ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)

	AutoParry.target.aim = (not is_mobile and Player.get_closest_player_to_cursor() or Player.get_aim_entity())

	if ball:GetAttribute('from') ~= nil then
		AutoParry.target.from = Alive:FindFirstChild(ball:GetAttribute('from'))
	end

	AutoParry.target.current = Alive:FindFirstChild(ball:GetAttribute('target'))

	if AutoParry.target == nil then
		return
	end

	ball_properties.rotation = ball_properties.position

	if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
		ball_properties.rotation = AutoParry.target.aim.PrimaryPart.Position

		return
	end

	if not AutoParry.target.current then
		return
	end

	local target_server_position = AutoParry.target.current.PrimaryPart.Position
	local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity

	AutoParry.entity_properties.server_position = target_server_position
	AutoParry.entity_properties.velocity = target_velocity
	AutoParry.entity_properties.distance = LocalPlayer:DistanceFromCharacter(target_server_position)
	AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
	AutoParry.entity_properties.speed = target_velocity.Magnitude
	AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
	AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0)
end)

local LocalPlayer = Players.LocalPlayer

local interface = loadstring(game:HttpGet('https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua'))()

local Window = interface:CreateWindow({
	Title = "Kairo BLADE BALL V3",
	SubTitle = "By Lenny And JosiahScripts",
	TabWidth = 180,
	Size = UDim2.fromOffset(600, 480),
	Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
	Theme = "Dark",
	MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

local Tabs = {
    Main = Window:AddTab({ Title = "Home", Icon = "home" }),
	Main = Window:AddTab({ Title = "Main", Icon = "sword" }),
    Debug = Window:AddTab({ Title = "Misc", Icon = "bug" }),
}

local home = Tabs.Main:AddToggle("home",{
		Title = "Hello, Sigma", 
		Description = "Kairo (blade ball) has been enhanced/updated to more accurate (99.99%) thanks to Lenny for helping me with this i love you lenny (imnotgay) THATS ALL!!!",
		Default = false,
	})

	local auto_parry = Tabs.Main:AddToggle("ap",{
		Title = "Auto Parry", 
		Description = "AUTO PARRIES THE BALL FOR YOU SIGMA",
		Default = false,
	})

	auto_parry:OnChanged(function(v)
		auto_parry_enabled = v
	end)


	local curve_method2 = Tabs.Main:AddDropdown("cm",{
		Title = "Curve Medthod",
		Description = "Curve Medthod",
		Values = {"Straight", "Backwards", "Randomize",},
		Multi = false,
		Default = 1,
	})

	curve_method2:OnChanged(function(v)
		current_curve = v
	end)


	local visualize = Tabs.Debug:AddToggle("vl",{
		Title = "Visualize/View Part", 
		Description = "Visualizes the ball's speed and range to be parried",
		Default = false,
	})
	
	visualize:OnChanged(function(v)
		visualize_Enabled = v
	end)


local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")

-- Variables to handle spam functionality
local debounce = false
local heartbeatConnection
local SpamOn = false
local spamFrequency = 0.001
local lastSpamTime = tick()

-- Variables for hit and parry remotes
local hitremote, parryremote

-- Search for both hit and parry remotes in the game's descendants
for _, v in pairs(game:GetDescendants()) do
    if v:IsA("RemoteEvent") then
        if v.Name:find("\n") then
            hitremote = v -- If it has a newline in its name, consider it the hit remote
        elseif v.Name:lower():find("parry") then
            parryremote = v -- If its name contains "parry", consider it the parry remote
        end
    end
end

local cframes = {}
for i = 1, 50 do
    table.insert(cframes, CFrame.new(math.random(-1000, 1000), math.random(0, 200), math.random(-200, 200)))
end

-- Get positions of other players
local function getPlayerPositions()
    local playersPos = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:IsDescendantOf(game.Workspace:FindFirstChild("Alive")) then
            local pos = player.Character.PrimaryPart.Position + Vector3.new(10, 10, 10)
            playersPos[player.Name] = pos
        end
    end
    return playersPos
end

local function getClosestPlayer()
    local closestPlayer
    local minDist = math.huge
    local playerPositions = getPlayerPositions()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and playerPositions[player.Name] then
            local dist = LocalPlayer:DistanceFromCharacter(playerPositions[player.Name])
            if dist < minDist then
                minDist = dist
                closestPlayer = player
            end
        end
    end
    return closestPlayer
end

-- Fire hit remote
local function fireHitRemote()
    if debounce then return end
    debounce = true
    delay(0.05, function() debounce = false end)

    local args = {
        [1] = 0.5,
        [2] = cframes[math.random(1, #cframes)],
        [3] = getClosestPlayer() and {[tostring(getClosestPlayer().Name)] = getClosestPlayer().Character.PrimaryPart.Position} or getPlayerPositions(),
        [4] = {
            [1] = math.random(300, 700),
            [2] = math.random(300, 700),
            [3] = math.random(300, 700),
        }
    }
    if hitremote then
        hitremote:FireServer(unpack(args))
    end
end

-- Fire parry remote
local function fireParryRemote()
    if parryremote then
        local args = {
            [1] = LocalPlayer.Character.PrimaryPart.Position,
            [2] = "Parry" -- Example argument for the parry action; this may need to be customized
        }
        parryremote:FireServer(unpack(args))
    end
end

-- Spam routine for both hit and parry remotes
local function spamRoutine()
    while SpamOn do
        if tick() - lastSpamTime >= spamFrequency then
            fireHitRemote()
            fireParryRemote() -- Call the parry remote as well in the routine
            lastSpamTime = tick()
        end
        task.wait(spamFrequency)
    end
end


local Spam = Instance.new("ScreenGui")
local BG = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Rectangle = Instance.new("Frame")
local LennyLabel = Instance.new("TextLabel")
local Toggle = Instance.new("TextButton")
local StatusPF = Instance.new("TextLabel")
local Status = Instance.new("TextLabel")

Spam.Name = "Spam"
Spam.Parent = CoreGui
Spam.Enabled = true


BG.Name = "BG"
BG.Parent = Spam
BG.BackgroundColor3 = Color3.new(0, 0, 0)
BG.BackgroundTransparency = 0.3
BG.BorderSizePixel = 0 
BG.Position = UDim2.new(0.5, -75, 0.5, -38)
BG.Size = UDim2.new(0, 120, 0, 90)
BG.Active = true
BG.Draggable = true 

UICorner.CornerRadius = UDim.new(0, 15) -- Round the corners
UICorner.Parent = BG


Rectangle.Name = "Rectangle"
Rectangle.Parent = BG -- Parent it to the background frame so it moves together
Rectangle.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1) -- Darker background for contrast
Rectangle.Size = UDim2.new(1, 0, 0, 25) -- Full width of BG
Rectangle.Position = UDim2.new(0, 0, 0, -25) -- Positioned above the BG
Rectangle.BorderSizePixel = 0 -- No border

local RectangleUICorner = Instance.new("UICorner")
RectangleUICorner.CornerRadius = UDim.new(0, 15) -- Rounded corners at the top
RectangleUICorner.Parent = Rectangle


LennyLabel.Name = "LennyLabel"
LennyLabel.Parent = Rectangle -- Attach to the Rectangle
LennyLabel.BackgroundTransparency = 1
LennyLabel.Size = UDim2.new(1, 0, 1, 0) -- Fill the Rectangle
LennyLabel.Font = Enum.Font.SourceSansBold
LennyLabel.Text = "By : Lenny"
LennyLabel.TextColor3 = Color3.new(1, 1, 1) -- White text
LennyLabel.TextSize = 18
LennyLabel.TextStrokeTransparency = 0.6 -- Subtle text stroke


Toggle.Parent = BG
Toggle.BackgroundColor3 = Color3.new(0, 0, 0) -- Black button
Toggle.BackgroundTransparency = 0.3
Toggle.Position = UDim2.new(0.5, -58, 0.6, -20)
Toggle.Size = UDim2.new(0, 117, 0, 30)
Toggle.Font = Enum.Font.SourceSansBold
Toggle.Text = "OFF" -- Initially Off
Toggle.TextColor3 = Color3.new(1, 0, 0) -- Red text for off
Toggle.TextSize = 18
UICorner:Clone().Parent = Toggle -- Rounded corners for the button


StatusPF.Name = "StatusPF"
StatusPF.Parent = BG
StatusPF.BackgroundTransparency = 1
StatusPF.Position = UDim2.new(0.5, -40, 0.85, -15)
StatusPF.Size = UDim2.new(0, 60, 0, 33)
StatusPF.Font = Enum.Font.SourceSansBold
StatusPF.Text = "Status:"
StatusPF.TextColor3 = Color3.new(1, 1, 1)
StatusPF.TextSize = 18
StatusPF.TextWrapped = true


Status.Name = "Status"
Status.Parent = BG
Status.BackgroundTransparency = 1
Status.Position = UDim2.new(0.5, 0, 0.84, -13)
Status.Size = UDim2.new(0, 50, 0, 33)
Status.Font = Enum.Font.SourceSansBold
Status.Text = "Off"
Status.TextColor3 = Color3.new(1, 0, 0) -- Red for "Off"
Status.TextSize = 18
Status.TextWrapped = true


local function UpdateToggleVisual()
    Toggle.Text = SpamOn and "ON" or "OFF"
    local color = SpamOn and Color3.new(0, 1, 0) or Color3.new(1, 0, 0) -- Green for "On", Red for "Off"

    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local tweenGoal = { TextStrokeColor3 = color, TextColor3 = color }

    local toggleTween = TweenService:Create(Toggle, tweenInfo, tweenGoal)
    toggleTween:Play()

    Status.Text = SpamOn and "On" or "Off"
    Status.TextColor3 = color
end


Toggle.MouseButton1Click:Connect(function()
    SpamOn = not SpamOn
    UpdateToggleVisual()

    if SpamOn then
        spamRoutine() -- Start the spam routine
    end
end)


Spam.AncestryChanged:Connect(function(_, parent)
    if not parent then
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
    end
end)

local Toggle6 = Tabs.Main:AddToggle("ap", {
        Title = "Manual spam",
        Description = "â€¢ Automatic Clicks For you",
        Default = false,
        Callback = function(Value)
            Spam.Enabled = Value
        end
    })

local dropdown_emotes_table = {}
local emote_instances = {}

for _, emote in ReplicatedStorage.Misc.Emotes:GetChildren() do
	local emote_name = emote:GetAttribute('EmoteName')

	if not emote_name then
		return
	end

	table.insert(dropdown_emotes_table, emote_name)
	emote_instances[emote_name] = emote
end

LocalPlayer.Idled:Connect(function()
	VirtualUser:CaptureController()
	VirtualUser:ClickButton2(Vector2.zero)
end)

local current_animation = nil
local current_animation_name = nil

local looped_emotes = {
	"Emote108",
	"Emote225",
	"Emote300",
	"Emote301"
}


local spamming_done = true :: boolean



RunService.PostSimulation:Connect(function()
	if not workspace.CurrentCamera then
		return
	end

	local character = LocalPlayer.Character

	if not character then
		return
	end



	if not gravity_enabled then
		workspace.Gravity = 196.2

		return
	end



	workspace.Gravity = 196.2 / (strength / 10)
end)

local function clear_skyboxes()
	for _, child in Lighting:GetChildren() do
		if not child:IsA('Sky') then
			continue
		end

		Debris:AddItem(child, 0)
	end
end




local staff_roles = {
	'content creator',
	'contributor',
	'trial qa',
	'tester',
	'mod'
}

Players.PlayerAdded:Connect(function(player)
	local is_friend = LocalPlayer:IsFriendsWith(player.UserId)



	if not personnel_detector_enabled then
		return
	end



	local player_role = tostring(player:GetRoleInGroup(12836673)):lower()
	local player_is_staff = table.find(staff_roles, player_role)

	if player_is_staff then
		game:Shutdown()

		return
	end
end)


local is_respawned = false :: boolean

workspace.Balls.ChildRemoved:Connect(function(child)
	is_respawned = false

	if child == AutoParry.ball.ball_entity then
		AutoParry.ball.ball_entity = nil
		AutoParry.ball.client_ball_entity = nil
		AutoParry.reset()
	end
end)

workspace.Balls.ChildAdded:Connect(function()
	if is_respawned then
		return
	end

	is_respawned = true

	local ball_properties = AutoParry.ball.properties

	ball_properties.respawn_time = tick()

	AutoParry.ball.ball_entity = AutoParry.get_ball()
	AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()

	local target = AutoParry.ball.ball_entity:GetAttribute('target')

	AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
		if target == LocalPlayer.Name then
			ball_properties.cooldown = false

			return
		end

		ball_properties.cooldown = false
		ball_properties.old_speed = ball_properties.speed
		ball_properties.last_position = ball_properties.position

		ball_properties.parries += 1

		task.delay(1, function()
			if ball_properties.parries > 0 then
				ball_properties.parries -= 1
			end
		end)	
	end)
end)

RunService.PreSimulation:Connect(function()
	if not AutoParry.ball.properties.auto_spam then
		return
	end

	for v = 1,3 do
		AutoParry.perform_parry()
	end
end)

local custom_win_audio = Instance.new('Sound', sounds_folder)



ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(slash: any, root: any)
	task.spawn(function()
		if root.Parent and root.Parent ~= LocalPlayer.Character then
			if root.Parent.Parent ~= Alive then
				return
			end

			AutoParry.ball.properties.cooldown = false
		end
	end)

	if AutoParry.ball.properties.auto_spam then
			for v = 1,3 do
		AutoParry.perform_parry()
	end
	end

    if AutoParry.target.current ~= LocalPlayer.Name then
        nowprediction = true
    end
end)

local custom_audio = Instance.new('Sound', sounds_folder)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
	if LocalPlayer.Character.Parent ~= Alive then
		return
	end

	if not Player.properties.grab_animation then
		return
	end



	Player.properties.grab_animation:Stop()

	local ball = AutoParry.get_client_ball()

	if not ball then
		return
	end


	if AutoParry.ball.properties.auto_spam then
			for v = 1,3 do
		AutoParry.perform_parry()
	end
	end


	ball = nil
end)


RunService.PostSimulation:Connect(function()

	if not auto_parry_enabled then
		AutoParry.reset()

		return
	end

	local Character = LocalPlayer.Character

	if not Character then
		return
	end

	if Character.Parent == Dead then
		AutoParry.reset()

		return
	end

	if not AutoParry.ball.ball_entity then
		return
	end

	local ball_properties = AutoParry.ball.properties

	ball_properties.is_curved = AutoParry.is_curved()

	local baseMoveAmount = 0.5
	local moveAmount = baseMoveAmount * (1 / (AutoParry.entity_properties.distance + 0.01)) * 1000

	local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 10, 16)
	local spam_accuracity = math.min(moveAmount + (ball_properties.maximum_speed / 8.4), (150 + moveAmount))
	local parry_accuracity = ball_properties.maximum_speed / 11.5 + ping_threshold

	ball_properties.spam_range = ping_threshold + ball_properties.speed / 2.3
	ball_properties.parry_range = ping_threshold + ball_properties.speed / math.pi
	
	

	if Player.Entity.properties.sword == 'Titan Blade' then
		ball_properties.parry_range += 11
		ball_properties.spam_range += 2
	end	

	local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)

	if ball_properties.auto_spam and AutoParry.target.current then
		ball_properties.auto_spam = AutoParry.is_spam({
			speed = ball_properties.speed,
			spam_accuracy = spam_accuracity,
			parries = ball_properties.parries,
			ball_speed = ball_properties.speed,
			range = ball_properties.spam_range / (3.15 - ping_threshold / 10),
			last_hit = ball_properties.last_hit,
			ball_distance = ball_properties.distance,
			maximum_speed = ball_properties.maximum_speed,
			old_speed = AutoParry.ball.properties.old_speed,
			entity_distance = AutoParry.entity_properties.distance,
			last_position_distance = distance_to_last_position,
		})
	end

	if ball_properties.auto_spam then
		return
	end





	if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
		ball_properties.auto_spam = AutoParry.is_spam({
			speed = ball_properties.speed,
			spam_accuracy = spam_accuracity,
			parries = ball_properties.parries,
			ball_speed = ball_properties.speed,
			range = ball_properties.spam_range,
			last_hit = ball_properties.last_hit,
			ball_distance = ball_properties.distance,
			maximum_speed = ball_properties.maximum_speed,
			old_speed = AutoParry.ball.properties.old_speed,
			entity_distance = AutoParry.entity_properties.distance,
			last_position_distance = distance_to_last_position,
		})
	end



	if ball_properties.auto_spam then
		return
	end

	if ball_properties.is_curved then
		return
	end

	if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracity then
		return
	end

	if AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character then
		return
	end

	local lastPosition = LocalPlayer.Character.PrimaryPart.Position 
	local target_Ball_Distance = (ball_properties.position - AutoParry.entity_properties.server_position).Magnitude
	
	if parry_mode == "Rage" then
		-- Check if the player is looking at the ball
		local playerLookDirection = LocalPlayer.Character.HumanoidRootPart.CFrame.LookVector
		local ballDirection = (ball_properties.position - LocalPlayer.Character.HumanoidRootPart.Position).Unit
		local dotProduct = playerLookDirection:Dot(ballDirection)
		
		local walkDirection = (LocalPlayer.Character.PrimaryPart.Position - lastPosition).Unit
		local walkDotProduct = walkDirection:Dot(ballDirection)
	
		if walkDotProduct > 0.5 then
			nowprediction = false -- à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸—à¸³à¸™à¸²à¸¢
			return
		end
		
		if dotProduct > 0.5 then
			if target_Ball_Distance <= 10 and AutoParry.entity_properties.distance <= 50 then
                if math.random(1,2) == 1 then
                    nowprediction = true -- à¸—à¸³à¸™à¸²à¸¢à¹„à¸”à¹‰
				-- Calculate the parry position based on the player's character position and orientation
				local parryPosition = LocalPlayer.Character.HumanoidRootPart.Position + (LocalPlayer.Character.HumanoidRootPart.CFrame.LookVector * 5)
				-- Fire the parry remote function
				    AutoParry.perform_parry()
                    else
                    nowprediction = false
                end

			end

		end
	end
    
    if parry_mode == "Legit" and not nowprediction then
        return
    end
	

	lastPosition = LocalPlayer.Character.PrimaryPart.Position 



	ball_properties.last_ball_pos = ball_properties.position

	AutoParry.perform_parry()

	task.spawn(function()
		repeat
			RunService.PreSimulation:Wait(0)
		until 
		(tick() - ball_properties.last_hit) > 1 - (ping_threshold / 100)

		ball_properties.cooldown = false
	end)
end)